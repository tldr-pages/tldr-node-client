#!/usr/bin/env node

const { Command } = require('commander'); // Commander 14
const pkg = require('../package');
const Tldr = require('../lib/tldr');
const config = require('../lib/config');
const platforms = require('../lib/platforms');
const Completion = require('../lib/completion');
const { TldrError } = require('../lib/errors');

const program = new Command();

pkg.version = `v${pkg.version} (Client Spec: 2.0)`;

// Basic CLI setup
program
  .name('tldr')
  .version(pkg.version) // Commander 14 only takes version string
  .description(pkg.description)
  .usage('command [options]')

// --------------------
// BASIC OPTIONS
// --------------------
program
  .option('-l, --list', 'List all commands for the chosen platform in the cache')
  .option('-a, --list-all', 'List all commands in the cache')
  .option('-1, --single-column', 'List single command per line (use with -l or -a)')
  .option('-r, --random', 'Show a random command')
  .option('-e, --random-example', 'Show a random example')
  .option('-f, --render [file]', 'Render a specific markdown [file]')
  .option('-m, --markdown', 'Output in markdown format')
  .option('-p, --platform [type]', `Override the current platform [${platforms.supportedPlatforms.join(', ')}]`)
  .option('-t, --theme [theme]', 'Color theme (simple, base16, ocean)')
  .option('-s, --search [keywords]', 'Search pages using keywords')
  .option('-u, --update', 'Update the local cache')
  .option('-c, --clear-cache', 'Clear the local cache');

// Add flags for each supported platform
for (const platform of platforms.supportedPlatforms) {
  program.option(`--${platform}`, `Override platform with ${platform}`);
}

// --------------------
// COMPLETION SUBCOMMAND
// --------------------
program
  .command('completion [shell]')
  .description('Generate and add shell completion script to your shell configuration')
  .action(async (shell) => {
    try {
      const completion = new Completion(shell);
      const script = await completion.getScript();
      await completion.appendScript(script);

      if (shell === 'zsh') {
        console.log('If completions don\'t work, rebuild ~/.zcompdump:');
        console.log('  rm -f ~/.zcompdump; compinit');
      }
    } catch (err) {
      console.error(err.stack || err);
      process.exit(1);
    }
  });

// --------------------
// CUSTOM HELP EXAMPLES
// --------------------
const helpText = `
Examples:

  $ tldr tar
  $ tldr du --platform=linux
  $ tldr --search "create symbolic link to file"
  $ tldr --list
  $ tldr --list-all
  $ tldr --random
  $ tldr --random-example

Cache control:

  $ tldr --update
  $ tldr --clear-cache

Render local file:

  $ tldr --render /path/to/file.md

Add shell completion:

  $ tldr completion bash
  $ tldr completion zsh
`;

program.addHelpText('after', helpText);

// --------------------
// PARSE ARGS
// --------------------
program.parse(process.argv);

// --------------------
// PLATFORM OVERRIDE
// --------------------
for (const platform of platforms.supportedPlatforms) {
  if (program[platform]) {
    program.platform = platform;
  }
}

let cfg = config.get();
if (program.platform && platforms.isSupported(program.platform)) {
  cfg.platform = program.platform;
}
if (program.theme) {
  cfg.theme = program.theme;
}

const tldr = new Tldr(cfg);

// --------------------
// COMMAND HANDLING
// --------------------
let promise = null;

if (program.list) {
  promise = tldr.list(program.singleColumn);
} else if (program.listAll) {
  promise = tldr.listAll(program.singleColumn);
} else if (program.random) {
  promise = tldr.random(program);
} else if (program.randomExample) {
  promise = tldr.randomExample();
} else if (program.clearCache) {
  promise = tldr.clearCache();
} else if (program.update) {
  promise = tldr.updateCache()
    .then(() => tldr.updateIndex());
} else if (program.render) {
  promise = tldr.render(program.render);
} else if (program.search) {
  program.args.unshift(program.search);
  promise = tldr.search(program.args);
} else if (program.args.length >= 1) {
  promise = tldr.get(program.args, program);
}

// --------------------
// EXIT HANDLING
// --------------------
if (!promise) {
  program.outputHelp();
  process.exitCode = 1;
} else {
  promise.catch((err) => {
    const output = TldrError.isTldrError(err)
      ? err.message
      : err.stack || err;
    console.error(output);
    process.exitCode = err.code || 1;
  });
}
